<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agar.io Clone - Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    canvas {
      background-color: #f0f8ff;
      display: block;
      border: 5px solid #000;
    }

    /* Fancy animated search input styles */
    .grid {
      height: 800px;
      width: 800px;
      background-image: linear-gradient(to right, #0f0f10 1px, transparent 1px),
        linear-gradient(to bottom, #0f0f10 1px, transparent 1px);
      background-size: 1rem 1rem;
      background-position: center center;
      position: absolute;
      z-index: -1;
      filter: blur(1px);
    }

    .white, .border, .darkBorderBg, .glow {
      max-height: 70px;
      max-width: 314px;
      height: 100%;
      width: 100%;
      position: absolute;
      overflow: hidden;
      z-index: -1;
      border-radius: 12px;
      filter: blur(3px);
    }

    .input {
      background-color: #010201;
      border: none;
      width: 301px;
      height: 56px;
      border-radius: 10px;
      color: white;
      padding-inline: 59px;
      font-size: 18px;
    }

    #poda {
      display: flex;
      align-items: center;
      justify-content: center;
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
    }

    .input::placeholder {
      color: #c0b9c0;
    }

    .input:focus {
      outline: none;
    }

    #main:focus-within > #input-mask {
      display: none;
    }

    #input-mask {
      pointer-events: none;
      width: 100px;
      height: 20px;
      position: absolute;
      background: linear-gradient(90deg, transparent, black);
      top: 18px;
      left: 70px;
    }

    #pink-mask {
      pointer-events: none;
      width: 30px;
      height: 20px;
      position: absolute;
      background: #cf30aa;
      top: 10px;
      left: 5px;
      filter: blur(20px);
      opacity: 0.8;
      transition: all 2s;
    }

    #main:hover > #pink-mask {
      opacity: 0;
    }

    .white {
      max-height: 63px;
      max-width: 307px;
      border-radius: 10px;
      filter: blur(2px);
    }

    .white::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(83deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      filter: brightness(1.4);
      background-image: conic-gradient(
        rgba(0, 0, 0, 0) 0%,
        #a099d8,
        rgba(0, 0, 0, 0) 8%,
        rgba(0, 0, 0, 0) 50%,
        #dfa2da,
        rgba(0, 0, 0, 0) 58%
      );
      transition: all 2s;
    }

    .border {
      max-height: 59px;
      max-width: 303px;
      border-radius: 11px;
      filter: blur(0.5px);
    }

    .border::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(70deg);
      position: absolute;
      width: 600px;
      height: 600px;
      filter: brightness(1.3);
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        #1c191c,
        #402fb5 5%,
        #1c191c 14%,
        #1c191c 50%,
        #cf30aa 60%,
        #1c191c 64%
      );
      transition: all 2s;
    }

    .darkBorderBg {
      max-height: 65px;
      max-width: 312px;
    }

    .darkBorderBg::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(82deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        rgba(0, 0, 0, 0),
        #18116a,
        rgba(0, 0, 0, 0) 10%,
        rgba(0, 0, 0, 0) 50%,
        #6e1b60,
        rgba(0, 0, 0, 0) 60%
      );
      transition: all 2s;
    }

    #poda:hover > .darkBorderBg::before {
      transform: translate(-50%, -50%) rotate(262deg);
    }
    #poda:hover > .glow::before {
      transform: translate(-50%, -50%) rotate(240deg);
    }
    #poda:hover > .white::before {
      transform: translate(-50%, -50%) rotate(263deg);
    }
    #poda:hover > .border::before {
      transform: translate(-50%, -50%) rotate(250deg);
    }

    #poda:focus-within > .darkBorderBg::before {
      transform: translate(-50%, -50%) rotate(442deg);
      transition: all 4s;
    }
    #poda:focus-within > .glow::before {
      transform: translate(-50%, -50%) rotate(420deg);
      transition: all 4s;
    }
    #poda:focus-within > .white::before {
      transform: translate(-50%, -50%) rotate(443deg);
      transition: all 4s;
    }
    #poda:focus-within > .border::before {
      transform: translate(-50%, -50%) rotate(430deg);
      transition: all 4s;
    }

    .glow {
      overflow: hidden;
      filter: blur(30px);
      opacity: 0.4;
      max-height: 130px;
      max-width: 354px;
    }

    .glow:before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(60deg);
      position: absolute;
      width: 999px;
      height: 999px;
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        #000,
        #402fb5 5%,
        #000 38%,
        #000 50%,
        #cf30aa 60%,
        #000 87%
      );
      transition: all 2s;
    }

    @keyframes rotate {
      100% {
        transform: translate(-50%, -50%) rotate(450deg);
      }
    }

    #filter-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      max-height: 40px;
      max-width: 38px;
      height: 100%;
      width: 100%;
      isolation: isolate;
      overflow: hidden;
      border-radius: 10px;
      background: linear-gradient(180deg, #161329, black, #1d1b4b);
      border: 1px solid transparent;
    }

    .filterBorder {
      height: 42px;
      width: 40px;
      position: absolute;
      overflow: hidden;
      top: 7px;
      right: 7px;
      border-radius: 10px;
    }

    .filterBorder::before {
      content: "";
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(90deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      filter: brightness(1.35);
      background-image: conic-gradient(
        rgba(0, 0, 0, 0),
        #3d3a4f,
        rgba(0, 0, 0, 0) 50%,
        rgba(0, 0, 0, 0) 50%,
        #3d3a4f,
        rgba(0, 0, 0, 0) 100%
      );
      animation: rotate 4s linear infinite;
    }

    #main {
      position: relative;
    }

    #search-icon {
      position: absolute;
      left: 20px;
      top: 15px;
    }

    /* Game UI Elements */
    button, input {
      position: fixed;
      z-index: 10;
      padding: 8px 12px;
      font-size: 14px;
      border: 2px solid #333;
      border-radius: 5px;
      background-color: rgba(240, 240, 240, 0.9);
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    input {
      background-color: rgba(255, 255, 255, 0.9);
    }

    button:hover {
      background-color: rgba(224, 224, 224, 0.9);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #stopButton {
      top: 10px;
      right: 250px;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
      color: white;
      border: none;
    }

    #restartButton {
      top: 10px;
      right: 140px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
    }

    #logoutButton {
      top: 10px;
      right: 20px;
      background: linear-gradient(135deg, #333 0%, #555 100%);
      color: white;
      border: none;
    }

    #leaderboard {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 15px;
      border-radius: 15px;
      min-width: 250px;
      z-index: 10;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #leaderboard h3 {
      margin: 0 0 10px 0;
      text-align: center;
      font-size: 18px;
      color: #ffdd44;
      text-shadow: 0 0 10px #ffdd44;
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 14px;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .leaderboard-entry:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .player-name {
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .player-score {
      font-weight: bold;
      color: #44ff44;
      text-shadow: 0 0 5px #44ff44;
    }

    #gameStats {
      position: fixed;
      top: 80px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px;
      border-radius: 10px;
      z-index: 10;
      font-size: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stat-item {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }

    .stat-value {
      font-weight: bold;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
    }

    /* Floating notifications */
    .notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px 40px;
      border-radius: 10px;
      font-size: 24px;
      z-index: 1000;
      backdrop-filter: blur(10px);
      border: 2px solid #ffdd44;
      animation: fadeInOut 3s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
  </style>
</head>
<body>
  
  <div class="grid"></div>
  
  <!-- Fancy search input as start button -->
  <div id="poda"> 
    <div class="glow"></div> 
    <div class="darkBorderBg"></div> 
    <div class="darkBorderBg"></div> 
    <div class="darkBorderBg"></div> 
    <div class="white"></div> 
    <div class="border"></div> 
    <div id="main"> 
      <input placeholder="Enter your name to start..." type="text" name="text" class="input" id="nameInput" /> 
      <div id="input-mask"></div> 
      <div id="pink-mask"></div> 
      <div class="filterBorder"></div> 
      <div id="filter-icon"> 
        <svg preserveAspectRatio="none" height="27" width="27" viewBox="4.8 4.56 14.832 15.408" fill="none"> 
          <path d="M8.16 6.65002H15.83C16.47 6.65002 16.99 7.17002 16.99 7.81002V9.09002C16.99 9.56002 16.7 10.14 16.41 10.43L13.91 12.64C13.56 12.93 13.33 13.51 13.33 13.98V16.48C13.33 16.83 13.1 17.29 12.81 17.47L12 17.98C11.24 18.45 10.2 17.92 10.2 16.99V13.91C10.2 13.5 9.97 12.98 9.73 12.69L7.52 10.36C7.23 10.08 7 9.55002 7 9.20002V7.87002C7 7.17002 7.52 6.65002 8.16 6.65002Z" stroke="#d6d6e6" stroke-width="1" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path> 
        </svg> 
      </div> 
      <div id="search-icon"> 
        <svg xmlns="http://www.w3.org/2000/svg" width="24" viewBox="0 0 24 24" stroke-width="2" stroke-linejoin="round" stroke-linecap="round" height="24" fill="none" class="feather feather-search"> 
          <circle stroke="url(#search)" r="8" cy="11" cx="11"></circle> 
          <line stroke="url(#searchl)" y2="16.65" y1="22" x2="16.65" x1="22"></line> 
          <defs> 
            <linearGradient gradientTransform="rotate(50)" id="search"> 
              <stop stop-color="#f8e7f8" offset="0%"></stop> 
              <stop stop-color="#b6a9b7" offset="50%"></stop> 
            </linearGradient> 
            <linearGradient id="searchl"> 
              <stop stop-color="#b6a9b7" offset="0%"></stop> 
              <stop stop-color="#837484" offset="50%"></stop> 
            </linearGradient> 
          </defs> 
        </svg> 
      </div> 
    </div>
  </div>

  <button id="stopButton">⏸ Stop</button>
  <button id="restartButton">🔄 Restart</button>
  <button id="logoutButton">🚪 Logout</button>
  
  <div id="gameStats">
    <div class="stat-item">
      <span>Score:</span>
      <span class="stat-value" id="scoreDisplay">0</span>
    </div>
    <div class="stat-item">
      <span>Mass:</span>
      <span class="stat-value" id="massDisplay">0</span>
    </div>
    <div class="stat-item">
      <span>Player:</span>
      <span class="stat-value" id="playerDisplay">Guest</span>
    </div>
  </div>
  
  <div id="leaderboard">
    <h3>🏆 Leaderboard</h3>
    <div id="leaderboardContent"></div>
  </div>
  
  <canvas id="gameCanvas"></canvas>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const gameWidth = 8000;
    const gameHeight = 8000;

    let userData = JSON.parse(localStorage.getItem('userData') || '{}');
    let camera = { x: 0, y: 0, zoom: 1 };

    let player = {
      x: gameWidth / 2,
      y: gameHeight / 2,
      radius: 25,
      color: '#' + Math.floor(Math.random()*16777215).toString(16),
      speed: 4,
      name: userData.username || '',
      score: 0,
      isPlayer: true
    };

    let allPlayers = [];
    let playerPieces = [player];
    let food = [];
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    let gameRunning = false;
    let gameLoopId = null;

    // Set canvas to fullscreen
    function setCanvasFullscreen() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      mouseX = canvas.width / 2;
      mouseY = canvas.height / 2;
    }

    setCanvasFullscreen();
    window.addEventListener('resize', setCanvasFullscreen);

    // Update player display
    document.getElementById('playerDisplay').textContent = userData.username || 'Guest';

    // Generate AI players with enhanced behavior
    function generateAIPlayers() {
      const aiNames = ['Alpha Bot', 'Beta Destroyer', 'Gamma Hunter', 'Delta Warrior', 'Epsilon King', 'Zeta Master', 'Eta Champion', 'Theta Legend'];
      const colors = ['#ff4757', '#2ed573', '#a55eea', '#fd9644', '#ff6b9d', '#26d0ce', '#fed330', '#a55eea'];
      
      for (let i = 0; i < 8; i++) {
        let aiPlayer = {
          x: Math.random() * (gameWidth - 200) + 100,
          y: Math.random() * (gameHeight - 200) + 100,
          radius: Math.random() * 25 + 20,
          color: colors[i],
          speed: Math.random() * 2 + 2.5,
          name: aiNames[i],
          score: Math.floor(Math.random() * 200) + 50,
          isPlayer: false,
          targetX: Math.random() * gameWidth,
          targetY: Math.random() * gameHeight,
          lastDirectionChange: 0,
          intelligence: Math.random() * 0.8 + 0.2
        };
        allPlayers.push(aiPlayer);
      }
    }

    function updateCamera() {
      // Smooth camera following with zoom based on player size
      camera.zoom = Math.max(0.4, Math.min(1.5, 500 / (player.radius + 200)));
      
      camera.x = player.x - canvas.width / (2 * camera.zoom);
      camera.y = player.y - canvas.height / (2 * camera.zoom);
      
      // Keep camera within bounds
      camera.x = Math.max(0, Math.min(camera.x, gameWidth - canvas.width / camera.zoom));
      camera.y = Math.max(0, Math.min(camera.y, gameHeight - canvas.height / camera.zoom));
    }

    function drawGrid() {
      const gridSize = 40;
      ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.lineWidth = 1;

      const startX = Math.floor(camera.x / gridSize) * gridSize;
      const startY = Math.floor(camera.y / gridSize) * gridSize;
      const endX = camera.x + canvas.width / camera.zoom;
      const endY = camera.y + canvas.height / camera.zoom;

      for (let x = startX; x <= endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo((x - camera.x) * camera.zoom, 0);
        ctx.lineTo((x - camera.x) * camera.zoom, canvas.height);
        ctx.stroke();
      }

      for (let y = startY; y <= endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, (y - camera.y) * camera.zoom);
        ctx.lineTo(canvas.width, (y - camera.y) * camera.zoom);
        ctx.stroke();
      }
    }

    function drawPlayer() {
      playerPieces.forEach(piece => {
        const screenX = (piece.x - camera.x) * camera.zoom;
        const screenY = (piece.y - camera.y) * camera.zoom;
        const screenRadius = piece.radius * camera.zoom;

        // Only draw if visible
        if (screenX + screenRadius > 0 && screenX - screenRadius < canvas.width &&
            screenY + screenRadius > 0 && screenY - screenRadius < canvas.height) {
          
          // Draw glow effect
          ctx.shadowColor = piece.color;
          ctx.shadowBlur = 20;
          
          ctx.beginPath();
          ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
          ctx.fillStyle = piece.color;
          ctx.fill();
          
          // Reset shadow
          ctx.shadowBlur = 0;
          
          // Draw border
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.stroke();

          // Draw name
          if (piece.name && screenRadius > 15) {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(12, screenRadius / 3)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeText(piece.name, screenX, screenY);
            ctx.fillText(piece.name, screenX, screenY);
          }
        }
      });
    }

    function drawAIPlayers() {
      allPlayers.forEach(aiPlayer => {
        const screenX = (aiPlayer.x - camera.x) * camera.zoom;
        const screenY = (aiPlayer.y - camera.y) * camera.zoom;
        const screenRadius = aiPlayer.radius * camera.zoom;

        // Only draw if visible
        if (screenX + screenRadius > 0 && screenX - screenRadius < canvas.width &&
            screenY + screenRadius > 0 && screenY - screenRadius < canvas.height) {
          
          ctx.beginPath();
          ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
          ctx.fillStyle = aiPlayer.color;
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw AI name
          if (screenRadius > 10) {
            ctx.fillStyle = 'white';
            ctx.font = `bold ${Math.max(10, screenRadius / 3)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.strokeText(aiPlayer.name, screenX, screenY);
            ctx.fillText(aiPlayer.name, screenX, screenY);
          }
        }
      });
    }

    function drawFood() {
      food.forEach((item) => {
        const screenX = (item.x - camera.x) * camera.zoom;
        const screenY = (item.y - camera.y) * camera.zoom;
        const screenRadius = item.radius * camera.zoom;

        // Only draw if visible
        if (screenX + screenRadius > 0 && screenX - screenRadius < canvas.width &&
            screenY + screenRadius > 0 && screenY - screenRadius < canvas.height) {
          
          ctx.beginPath();
          ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
          ctx.fillStyle = item.color;
          ctx.fill();
        }
      });
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function updateAIPlayers() {
      allPlayers.forEach(aiPlayer => {
        // Enhanced AI behavior
        if (Date.now() - aiPlayer.lastDirectionChange > 3000 * aiPlayer.intelligence) {
          // Sometimes hunt food, sometimes avoid bigger players
          if (Math.random() < 0.7) {
            // Hunt for food
            let nearestFood = null;
            let nearestDistance = Infinity;
            
            food.forEach(item => {
              const distance = Math.sqrt(
                (aiPlayer.x - item.x) ** 2 + (aiPlayer.y - item.y) ** 2
              );
              if (distance < nearestDistance && distance < 300) {
                nearestDistance = distance;
                nearestFood = item;
              }
            });
            
            if (nearestFood) {
              aiPlayer.targetX = nearestFood.x;
              aiPlayer.targetY = nearestFood.y;
            } else {
              aiPlayer.targetX = Math.random() * gameWidth;
              aiPlayer.targetY = Math.random() * gameHeight;
            }
          } else {
            // Random movement
            aiPlayer.targetX = Math.random() * gameWidth;
            aiPlayer.targetY = Math.random() * gameHeight;
          }
          
          aiPlayer.lastDirectionChange = Date.now();
        }

        // Move towards target
        let dx = aiPlayer.targetX - aiPlayer.x;
        let dy = aiPlayer.targetY - aiPlayer.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 10) {
          let moveX = (dx / distance) * aiPlayer.speed;
          let moveY = (dy / distance) * aiPlayer.speed;
          
          aiPlayer.x = Math.max(aiPlayer.radius, Math.min(aiPlayer.x + moveX, gameWidth - aiPlayer.radius));
          aiPlayer.y = Math.max(aiPlayer.radius, Math.min(aiPlayer.y + moveY, gameHeight - aiPlayer.radius));
        }

        // AI eats food
        food.forEach((item, index) => {
          let dx = aiPlayer.x - item.x;
          let dy = aiPlayer.y - item.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < aiPlayer.radius + item.radius) {
            food.splice(index, 1);
            aiPlayer.radius += item.radius / 8;
            aiPlayer.score += 2;
          }
        });
      });
    }

    function updateLeaderboard() {
      let allPlayersData = [];
      
      // Add human player
      if (player.name) {
        allPlayersData.push({
          name: player.name,
          score: player.score,
          isHuman: true
        });
      }
      
      // Add AI players
      allPlayers.forEach(aiPlayer => {
        allPlayersData.push({
          name: aiPlayer.name,
          score: aiPlayer.score,
          isHuman: false
        });
      });

      // Sort by score
      allPlayersData.sort((a, b) => b.score - a.score);

      // Update leaderboard display
      const leaderboardContent = document.getElementById('leaderboardContent');
      leaderboardContent.innerHTML = '';

      allPlayersData.slice(0, 10).forEach((playerData, index) => {
        const entry = document.createElement('div');
        entry.className = 'leaderboard-entry';
        
        const rank = index + 1;
        const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
        
        entry.innerHTML = `
          <span class="player-name">${medal} ${playerData.name}${playerData.isHuman ? ' (You)' : ''}</span>
          <span class="player-score">${playerData.score}</span>
        `;
        
        if (playerData.isHuman) {
          entry.style.background = 'linear-gradient(90deg, rgba(68, 255, 68, 0.2), rgba(68, 255, 68, 0.1))';
          entry.style.borderLeft = '3px solid #44ff44';
        }
        
        leaderboardContent.appendChild(entry);
      });
    }

    function showNotification(message) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 3000);
    }

    function update() {
      clearCanvas();
      updateCamera();
      
      ctx.save();
      drawGrid();
      drawFood();
      drawAIPlayers();
      drawPlayer();
      ctx.restore();

      // Update game stats
      document.getElementById('scoreDisplay').textContent = player.score;
      document.getElementById('massDisplay').textContent = Math.floor(player.radius);

      updateLeaderboard();

      // Check for collision with food (player)
      food.forEach((item, index) => {
        playerPieces.forEach(piece => {
          let dx = piece.x - item.x;
          let dy = piece.y - item.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < piece.radius + item.radius) {
            food.splice(index, 1);
            piece.radius += item.radius / 6;
            player.score += 1;
          }
        });
      });

      // Move player towards mouse
      playerPieces.forEach(piece => {
        const worldMouseX = camera.x + mouseX / camera.zoom;
        const worldMouseY = camera.y + mouseY / camera.zoom;
        
        let angle = Math.atan2(worldMouseY - piece.y, worldMouseX - piece.x);
        let dx = Math.cos(angle) * piece.speed;
        let dy = Math.sin(angle) * piece.speed;

        piece.x = Math.max(piece.radius, Math.min(piece.x + dx, gameWidth - piece.radius));
        piece.y = Math.max(piece.radius, Math.min(piece.y + dy, gameHeight - piece.radius));
      });

      // Update player reference for camera
      if (playerPieces.length > 0) {
        player.x = playerPieces[0].x;
        player.y = playerPieces[0].y;
        player.radius = playerPieces[0].radius;
      }

      updateAIPlayers();
    }

    function generateFood() {
      while (food.length < 800) {
        let foodX = Math.random() * gameWidth;
        let foodY = Math.random() * gameHeight;
        let foodRadius = Math.random() * 6 + 4;
        let foodColor = '#' + Math.floor(Math.random() * 16777215).toString(16);
        food.push({ x: foodX, y: foodY, radius: foodRadius, color: foodColor });
      }
    }

    function splitPlayer() {
      if (playerPieces.length === 1 && player.radius > 25) {
        const newRadius = player.radius * 0.7;
        const originalPiece = playerPieces[0];
        
        const worldMouseX = camera.x + mouseX / camera.zoom;
        const worldMouseY = camera.y + mouseY / camera.zoom;
        let angle = Math.atan2(worldMouseY - originalPiece.y, worldMouseX - originalPiece.x);
        
        playerPieces.push({
          x: originalPiece.x + newRadius * Math.cos(angle) * 2,
          y: originalPiece.y + newRadius * Math.sin(angle) * 2,
          radius: newRadius,
          color: originalPiece.color,
          speed: originalPiece.speed * 1.5,
          name: originalPiece.name
        });
        
        originalPiece.radius = newRadius;
        
        showNotification('Player Split!');
      }
    }

    function gameLoop() {
      if (gameRunning) {
        update();
        generateFood();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
    }

    // Event listeners
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    window.addEventListener('keydown', function(event) {
      if (event.key === ' ') {
        event.preventDefault();
        splitPlayer();
      }
    });

    document.getElementById('nameInput').addEventListener('keypress', function(event) {
      if (event.key === 'Enter') {
        startGame();
      }
    });

    document.getElementById('nameInput').addEventListener('focus', function() {
      if (!gameRunning) {
        this.placeholder = 'Press Enter to start!';
      }
    });

    function startGame() {
      const playerName = document.getElementById('nameInput').value || userData.username || 'Anonymous';
      player.name = playerName;
      playerPieces[0].name = playerName;
      
      if (!gameRunning) {
        generateAIPlayers();
        generateFood();
        gameRunning = true;
        gameLoop();
        
        // Hide the fancy input
        document.getElementById('poda').style.display = 'none';
        
        showNotification(`Welcome ${playerName}! Use mouse to move, SPACE to split!`);
      }
    }

    document.getElementById('stopButton').addEventListener('click', function() {
      if (gameRunning) {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        showNotification('Game Paused');
      } else {
        gameRunning = true;
        gameLoop();
        showNotification('Game Resumed');
      }
      this.textContent = gameRunning ? '⏸ Stop' : '▶ Start';
    });

    document.getElementById('restartButton').addEventListener('click', function() {
      if (confirm('Are you sure you want to restart?')) {
        // Save score before restart
        if (player.score > 0) {
          fetch('/update_score', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ score: player.score })
          });
        }
        window.location.reload();
      }
    });

    document.getElementById('logoutButton').addEventListener('click', function() {
      if (confirm('Are you sure you want to logout?')) {
        // Save score before logout
        if (player.score > 0) {
          fetch('/update_score', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ score: player.score })
          });
        }
        localStorage.removeItem('userData');
        window.location.href = '/logout';
      }
    });

    // Auto-save score periodically
    setInterval(() => {
      if (gameRunning && player.score > 0) {
        fetch('/update_score', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ score: player.score })
        }).catch(err => console.log('Score save failed:', err));
      }
    }, 30000); // Save every 30 seconds

    // Generate initial food
    generateFood();

    // Show initial notification
    setTimeout(() => {
      showNotification('🎮 Enter your name in the fancy input to start playing!');
    }, 1000);
  </script> 
</body>
</html>