<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agar.io - Enhanced Edition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
    }

    canvas {
      background: radial-gradient(circle at center, #001122 0%, #000511 100%);
      display: block;
      border: 3px solid #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    /* Top Controls */
    .top-controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      gap: 15px;
      align-items: center;
    }

    /* Animated Search Input for Start Button */
    .grid {
      height: 800px;
      width: 800px;
      background-image: linear-gradient(to right, #0f0f10 1px, transparent 1px),
        linear-gradient(to bottom, #0f0f10 1px, transparent 1px);
      background-size: 1rem 1rem;
      background-position: center center;
      position: absolute;
      z-index: -1;
      filter: blur(1px);
    }

    .white, .border, .darkBorderBg, .glow {
      max-height: 70px;
      max-width: 314px;
      height: 100%;
      width: 100%;
      position: absolute;
      overflow: hidden;
      z-index: -1;
      border-radius: 12px;
      filter: blur(3px);
    }

    .input {
      background-color: #010201;
      border: none;
      width: 301px;
      height: 56px;
      border-radius: 10px;
      color: white;
      padding-inline: 59px;
      font-size: 18px;
    }

    #poda {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .input::placeholder {
      color: #c0b9c0;
    }

    .input:focus {
      outline: none;
    }

    #main:focus-within > #input-mask {
      display: none;
    }

    #input-mask {
      pointer-events: none;
      width: 100px;
      height: 20px;
      position: absolute;
      background: linear-gradient(90deg, transparent, black);
      top: 18px;
      left: 70px;
    }

    #pink-mask {
      pointer-events: none;
      width: 30px;
      height: 20px;
      position: absolute;
      background: #cf30aa;
      top: 10px;
      left: 5px;
      filter: blur(20px);
      opacity: 0.8;
      transition: all 2s;
    }

    #main:hover > #pink-mask {
      opacity: 0;
    }

    .white {
      max-height: 63px;
      max-width: 307px;
      border-radius: 10px;
      filter: blur(2px);
    }

    .white::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(83deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      filter: brightness(1.4);
      background-image: conic-gradient(
        rgba(0, 0, 0, 0) 0%,
        #a099d8,
        rgba(0, 0, 0, 0) 8%,
        rgba(0, 0, 0, 0) 50%,
        #dfa2da,
        rgba(0, 0, 0, 0) 58%
      );
      transition: all 2s;
    }

    .border {
      max-height: 59px;
      max-width: 303px;
      border-radius: 11px;
      filter: blur(0.5px);
    }

    .border::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(70deg);
      position: absolute;
      width: 600px;
      height: 600px;
      filter: brightness(1.3);
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        #1c191c,
        #402fb5 5%,
        #1c191c 14%,
        #1c191c 50%,
        #cf30aa 60%,
        #1c191c 64%
      );
      transition: all 2s;
    }

    .darkBorderBg {
      max-height: 65px;
      max-width: 312px;
    }

    .darkBorderBg::before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(82deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        rgba(0, 0, 0, 0),
        #18116a,
        rgba(0, 0, 0, 0) 10%,
        rgba(0, 0, 0, 0) 50%,
        #6e1b60,
        rgba(0, 0, 0, 0) 60%
      );
      transition: all 2s;
    }

    #poda:hover > .darkBorderBg::before {
      transform: translate(-50%, -50%) rotate(262deg);
    }

    #poda:hover > .glow::before {
      transform: translate(-50%, -50%) rotate(240deg);
    }

    #poda:hover > .white::before {
      transform: translate(-50%, -50%) rotate(263deg);
    }

    #poda:hover > .border::before {
      transform: translate(-50%, -50%) rotate(250deg);
    }

    #poda:focus-within > .darkBorderBg::before {
      transform: translate(-50%, -50%) rotate(442deg);
      transition: all 4s;
    }

    #poda:focus-within > .glow::before {
      transform: translate(-50%, -50%) rotate(420deg);
      transition: all 4s;
    }

    #poda:focus-within > .white::before {
      transform: translate(-50%, -50%) rotate(443deg);
      transition: all 4s;
    }

    #poda:focus-within > .border::before {
      transform: translate(-50%, -50%) rotate(430deg);
      transition: all 4s;
    }

    .glow {
      overflow: hidden;
      filter: blur(30px);
      opacity: 0.4;
      max-height: 130px;
      max-width: 354px;
    }

    .glow:before {
      content: "";
      z-index: -2;
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(60deg);
      position: absolute;
      width: 999px;
      height: 999px;
      background-repeat: no-repeat;
      background-position: 0 0;
      background-image: conic-gradient(
        #000,
        #402fb5 5%,
        #000 38%,
        #000 50%,
        #cf30aa 60%,
        #000 87%
      );
      transition: all 2s;
    }

    @keyframes rotate {
      100% {
        transform: translate(-50%, -50%) rotate(450deg);
      }
    }

    #filter-icon {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      max-height: 40px;
      max-width: 38px;
      height: 100%;
      width: 100%;
      isolation: isolate;
      overflow: hidden;
      border-radius: 10px;
      background: linear-gradient(180deg, #161329, black, #1d1b4b);
      border: 1px solid transparent;
    }

    .filterBorder {
      height: 42px;
      width: 40px;
      position: absolute;
      overflow: hidden;
      top: 7px;
      right: 7px;
      border-radius: 10px;
    }

    .filterBorder::before {
      content: "";
      text-align: center;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(90deg);
      position: absolute;
      width: 600px;
      height: 600px;
      background-repeat: no-repeat;
      background-position: 0 0;
      filter: brightness(1.35);
      background-image: conic-gradient(
        rgba(0, 0, 0, 0),
        #3d3a4f,
        rgba(0, 0, 0, 0) 50%,
        rgba(0, 0, 0, 0) 50%,
        #3d3a4f,
        rgba(0, 0, 0, 0) 100%
      );
      animation: rotate 4s linear infinite;
    }

    #main {
      position: relative;
    }

    #search-icon {
      position: absolute;
      left: 20px;
      top: 15px;
    }

    /* Regular Buttons */
    .game-button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .game-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }

    .stop-button {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
    }

    .stop-button:hover {
      background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
    }

    .restart-button {
      background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
      margin-left: 10px;
    }

    .restart-button:hover {
      background: linear-gradient(135deg, #44a08d 0%, #4ecdc4 100%);
    }

    /* User Info Panel */
    .user-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
      z-index: 100;
    }

    .user-info {
      color: #00ffff;
      font-weight: bold;
      margin-bottom: 10px;
    }

    #gameStats {
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
    }

    .stat-value {
      color: #00ffff;
      font-weight: bold;
    }

    /* Leaderboard */
    #leaderboard {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border-radius: 15px;
      min-width: 250px;
      z-index: 100;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
    }

    #leaderboard h3 {
      margin: 0 0 15px 0;
      text-align: center;
      font-size: 18px;
      color: #00ffff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .leaderboard-entry {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 14px;
      padding: 5px;
      border-radius: 5px;
      transition: all 0.3s ease;
    }

    .leaderboard-entry:hover {
      background: rgba(0, 255, 255, 0.1);
    }

    .player-name {
      max-width: 150px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .player-score {
      font-weight: bold;
      color: #00ff88;
    }

    /* Logout Button */
    .logout-btn {
      background: linear-gradient(135deg, #ff4757 0%, #c44569 100%);
      border: none;
      color: white;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: linear-gradient(135deg, #c44569 0%, #ff4757 100%);
      transform: translateY(-1px);
    }

    /* Enhanced Visual Effects */
    .glow-effect {
      animation: pulse 2s ease-in-out infinite alternate;
    }

    @keyframes pulse {
      from { filter: drop-shadow(0 0 5px rgba(0, 255, 255, 0.5)); }
      to { filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.8)); }
    }

    /* Mini-map */
    .mini-map {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 150px;
      height: 150px;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 10px;
      z-index: 100;
    }

    #miniCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <!-- User Panel -->
  <div class="user-panel">
    <div class="user-info">🎮 Player: {{ username }}</div>
    <div id="gameStats">
      <div class="stat-row">
        <span>Score:</span>
        <span class="stat-value" id="scoreDisplay">0</span>
      </div>
      <div class="stat-row">
        <span>Mass:</span>
        <span class="stat-value" id="massDisplay">0</span>
      </div>
      <div class="stat-row">
        <span>Cells:</span>
        <span class="stat-value" id="cellsDisplay">1</span>
      </div>
    </div>
    <button class="logout-btn" onclick="logout()">Logout</button>
  </div>

  <!-- Top Controls with Animated Search Input -->
  <div class="top-controls">
    <div id="poda"> 
      <div class="glow"></div> 
      <div class="darkBorderBg"></div> 
      <div class="darkBorderBg"></div> 
      <div class="darkBorderBg"></div> 
      <div class="white"></div> 
      <div class="border"></div> 
      <div id="main"> 
        <input placeholder="Enter your name to start..." type="text" name="text" class="input" id="nameInput" /> 
        <div id="input-mask"></div> 
        <div id="pink-mask"></div> 
        <div class="filterBorder"></div> 
        <div id="filter-icon"> 
          <svg preserveAspectRatio="none" height="27" width="27" viewBox="4.8 4.56 14.832 15.408" fill="none"> 
            <path d="M8.16 6.65002H15.83C16.47 6.65002 16.99 7.17002 16.99 7.81002V9.09002C16.99 9.56002 16.7 10.14 16.41 10.43L13.91 12.64C13.56 12.93 13.33 13.51 13.33 13.98V16.48C13.33 16.83 13.1 17.29 12.81 17.47L12 17.98C11.24 18.45 10.2 17.92 10.2 16.99V13.91C10.2 13.5 9.97 12.98 9.73 12.69L7.52 10.36C7.23 10.08 7 9.55002 7 9.20002V7.87002C7 7.17002 7.52 6.65002 8.16 6.65002Z" stroke="#d6d6e6" stroke-width="1" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"></path> 
          </svg> 
        </div> 
        <div id="search-icon"> 
          <svg xmlns="http://www.w3.org/2000/svg" width="24" viewBox="0 0 24 24" stroke-width="2" stroke-linejoin="round" stroke-linecap="round" height="24" fill="none" class="feather feather-search"> 
            <circle stroke="url(#search)" r="8" cy="11" cx="11"></circle> 
            <line stroke="url(#searchl)" y2="16.65" y1="22" x2="16.65" x1="22"></line> 
            <defs> 
              <linearGradient gradientTransform="rotate(50)" id="search"> 
                <stop stop-color="#f8e7f8" offset="0%"></stop> 
                <stop stop-color="#b6a9b7" offset="50%"></stop> 
              </linearGradient> 
              <linearGradient id="searchl"> 
                <stop stop-color="#b6a9b7" offset="0%"></stop> 
                <stop stop-color="#837484" offset="50%"></stop> 
              </linearGradient> 
            </defs> 
          </svg> 
        </div> 
      </div>
    </div>

    <button class="game-button" id="startButton">🚀 START GAME</button>
    <button class="game-button stop-button" id="stopButton">⏹️ STOP</button>
    <button class="game-button restart-button" id="restartButton">🔄 RESTART</button>
  </div>

  <!-- Leaderboard -->
  <div id="leaderboard">
    <h3>🏆 LEADERBOARD</h3>
    <div id="leaderboardContent"></div>
  </div>

  <!-- Mini Map -->
  <div class="mini-map">
    <canvas id="miniCanvas" width="150" height="150"></canvas>
  </div>

  <!-- Game Canvas -->
  <canvas id="gameCanvas" class="glow-effect"></canvas>
  
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const miniCanvas = document.getElementById('miniCanvas');
    const miniCtx = miniCanvas.getContext('2d');

    const gameWidth = 10000;
    const gameHeight = 10000;

    let player = {
      x: gameWidth / 2,
      y: gameHeight / 2,
      radius: 25,
      color: '#00ffff',
      speed: 3,
      name: '{{ username }}',
      score: 0,
      isPlayer: true
    };

    let allPlayers = [];
    let playerPieces = [player];
    let food = [];
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;

    let gameRunning = false;
    let gameLoopId = null;
    let camera = { x: 0, y: 0 };

    // Set the canvas to fullscreen
    function setCanvasFullscreen() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    setCanvasFullscreen();
    window.addEventListener('resize', setCanvasFullscreen);

    // Enhanced AI Players
    function generateAIPlayers() {
      const aiNames = ['🤖 Alpha', '🔥 Beta', '⚡ Gamma', '💎 Delta', '🌟 Epsilon', '🎯 Zeta', '💫 Eta', '🌈 Theta'];
      const colors = ['#ff4757', '#2ed573', '#a55eea', '#ffa502', '#ff6b9d', '#26d0ce', '#ffdd59', '#8b4513'];
      
      for (let i = 0; i < 8; i++) {
        let aiPlayer = {
          x: Math.random() * (gameWidth - 200) + 100,
          y: Math.random() * (gameHeight - 200) + 100,
          radius: Math.random() * 35 + 20,
          color: colors[i],
          speed: Math.random() * 2.5 + 1.5,
          name: aiNames[i],
          score: Math.floor(Math.random() * 150),
          isPlayer: false,
          targetX: Math.random() * gameWidth,
          targetY: Math.random() * gameHeight,
          lastDirectionChange: 0,
          aggressiveness: Math.random()
        };
        allPlayers.push(aiPlayer);
      }
    }

    // Enhanced Grid Drawing
    function drawGrid() {
      const gridSize = 100;
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
      ctx.lineWidth = 1;

      const startX = Math.floor(camera.x / gridSize) * gridSize;
      const startY = Math.floor(camera.y / gridSize) * gridSize;
      const endX = camera.x + canvas.width;
      const endY = camera.y + canvas.height;

      for (let x = startX; x <= endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x - camera.x, 0);
        ctx.lineTo(x - camera.x, canvas.height);
        ctx.stroke();
      }

      for (let y = startY; y <= endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y - camera.y);
        ctx.lineTo(canvas.width, y - camera.y);
        ctx.stroke();
      }
    }

    // Enhanced Player Drawing with Glow Effects
    function drawPlayer() {
      playerPieces.forEach(piece => {
        const screenX = piece.x - camera.x;
        const screenY = piece.y - camera.y;

        // Glow effect
        ctx.shadowColor = piece.color;
        ctx.shadowBlur = 20;
        
        // Main circle
        ctx.beginPath();
        ctx.arc(screenX, screenY, piece.radius, 0, Math.PI * 2);
        ctx.fillStyle = piece.color;
        ctx.fill();
        
        // Border
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Name
        if (piece.name) {
          ctx.fillStyle = '#ffffff';
          ctx.font = `bold ${Math.max(16, piece.radius / 2)}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          ctx.strokeText(piece.name, screenX, screenY);
          ctx.fillText(piece.name, screenX, screenY);
        }
      });
    }

    // Enhanced AI Drawing
    function drawAIPlayers() {
      allPlayers.forEach(aiPlayer => {
        const screenX = aiPlayer.x - camera.x;
        const screenY = aiPlayer.y - camera.y;

        // Only draw if on screen
        if (screenX > -aiPlayer.radius && screenX < canvas.width + aiPlayer.radius &&
            screenY > -aiPlayer.radius && screenY < canvas.height + aiPlayer.radius) {
          
          // Glow effect for larger players
          if (aiPlayer.radius > 30) {
            ctx.shadowColor = aiPlayer.color;
            ctx.shadowBlur = 15;
          }

          ctx.beginPath();
          ctx.arc(screenX, screenY, aiPlayer.radius, 0, Math.PI * 2);
          ctx.fillStyle = aiPlayer.color;
          ctx.fill();
          
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Name
          ctx.fillStyle = '#ffffff';
          ctx.font = `bold ${Math.max(12, aiPlayer.radius / 3)}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 1;
          ctx.strokeText(aiPlayer.name, screenX, screenY);
          ctx.fillText(aiPlayer.name, screenX, screenY);
        }
      });
    }

    // Enhanced Food Drawing
    function drawFood() {
      food.forEach((item) => {
        const screenX = item.x - camera.x;
        const screenY = item.y - camera.y;

        if (screenX > -item.radius && screenX < canvas.width + item.radius &&
            screenY > -item.radius && screenY < canvas.height + item.radius) {
          
          ctx.shadowColor = item.color;
          ctx.shadowBlur = 5;
          
          ctx.beginPath();
          ctx.arc(screenX, screenY, item.radius, 0, Math.PI * 2);
          ctx.fillStyle = item.color;
          ctx.fill();
          
          ctx.shadowBlur = 0;
        }
      });
    }

    // Camera System
    function updateCamera() {
      const targetX = player.x - canvas.width / 2;
      const targetY = player.y - canvas.height / 2;
      
      camera.x += (targetX - camera.x) * 0.1;
      camera.y += (targetY - camera.y) * 0.1;
      
      // Keep camera within bounds
      camera.x = Math.max(0, Math.min(camera.x, gameWidth - canvas.width));
      camera.y = Math.max(0, Math.min(camera.y, gameHeight - canvas.height));
    }

    // Mini Map
    function drawMiniMap() {
      miniCtx.clearRect(0, 0, 150, 150);
      
      // Background
      miniCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
      miniCtx.fillRect(0, 0, 150, 150);
      
      // Border
      miniCtx.strokeStyle = '#00ffff';
      miniCtx.lineWidth = 2;
      miniCtx.strokeRect(0, 0, 150, 150);
      
      const scaleX = 150 / gameWidth;
      const scaleY = 150 / gameHeight;
      
      // Player
      miniCtx.fillStyle = player.color;
      miniCtx.beginPath();
      miniCtx.arc(player.x * scaleX, player.y * scaleY, Math.max(2, player.radius * scaleX), 0, Math.PI * 2);
      miniCtx.fill();
      
      // AI Players
      allPlayers.forEach(ai => {
        miniCtx.fillStyle = ai.color;
        miniCtx.beginPath();
        miniCtx.arc(ai.x * scaleX, ai.y * scaleY, Math.max(1, ai.radius * scaleX), 0, Math.PI * 2);
        miniCtx.fill();
      });
      
      // Viewport indicator
      miniCtx.strokeStyle = '#ffffff';
      miniCtx.lineWidth = 1;
      miniCtx.strokeRect(camera.x * scaleX, camera.y * scaleY, canvas.width * scaleX, canvas.height * scaleY);
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Enhanced AI Behavior
    function updateAIPlayers() {
      allPlayers.forEach(aiPlayer => {
        // More intelligent AI movement
        if (Date.now() - aiPlayer.lastDirectionChange > 3000) {
          // Look for nearby food or smaller players
          let closestTarget = null;
          let closestDistance = Infinity;
          
          // Check food
          food.forEach(item => {
            const distance = Math.sqrt(Math.pow(aiPlayer.x - item.x, 2) + Math.pow(aiPlayer.y - item.y, 2));
            if (distance < closestDistance && distance < 300) {
              closestTarget = item;
              closestDistance = distance;
            }
          });
          
          // Check smaller players
          [...allPlayers, ...playerPieces].forEach(otherPlayer => {
            if (otherPlayer !== aiPlayer && otherPlayer.radius < aiPlayer.radius * 0.8) {
              const distance = Math.sqrt(Math.pow(aiPlayer.x - otherPlayer.x, 2) + Math.pow(aiPlayer.y - otherPlayer.y, 2));
              if (distance < closestDistance && distance < 400) {
                closestTarget = otherPlayer;
                closestDistance = distance;
              }
            }
          });
          
          if (closestTarget) {
            aiPlayer.targetX = closestTarget.x;
            aiPlayer.targetY = closestTarget.y;
          } else {
            aiPlayer.targetX = Math.random() * gameWidth;
            aiPlayer.targetY = Math.random() * gameHeight;
          }
          
          aiPlayer.lastDirectionChange = Date.now();
        }

        let dx = aiPlayer.targetX - aiPlayer.x;
        let dy = aiPlayer.targetY - aiPlayer.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 15) {
          let moveX = (dx / distance) * aiPlayer.speed;
          let moveY = (dy / distance) * aiPlayer.speed;
          
          aiPlayer.x = Math.max(aiPlayer.radius, Math.min(aiPlayer.x + moveX, gameWidth - aiPlayer.radius));
          aiPlayer.y = Math.max(aiPlayer.radius, Math.min(aiPlayer.y + moveY, gameHeight - aiPlayer.radius));
        }

        // AI eats food
        food.forEach((item, index) => {
          let dx = aiPlayer.x - item.x;
          let dy = aiPlayer.y - item.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < aiPlayer.radius + item.radius) {
            food.splice(index, 1);
            aiPlayer.radius += item.radius / 8;
            aiPlayer.score += 2;
          }
        });
      });
    }

    // Enhanced Leaderboard
    function updateLeaderboard() {
      let allPlayersData = [];
      
      if (player.name) {
        allPlayersData.push({
          name: player.name,
          score: player.score,
          isHuman: true
        });
      }
      
      allPlayers.forEach(aiPlayer => {
        allPlayersData.push({
          name: aiPlayer.name,
          score: aiPlayer.score,
          isHuman: false
        });
      });

      allPlayersData.sort((a, b) => b.score - a.score);

      const leaderboardContent = document.getElementById('leaderboardContent');
      leaderboardContent.innerHTML = '';

      allPlayersData.slice(0, 10).forEach((playerData, index) => {
        const entry = document.createElement('div');
        entry.className = 'leaderboard-entry';
        
        const rank = index + 1;
        const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
        
        entry.innerHTML = `
          <span class="player-name">${medal} ${playerData.name}${playerData.isHuman ? ' (You)' : ''}</span>
          <span class="player-score">${playerData.score}</span>
        `;
        
        if (playerData.isHuman) {
          entry.style.background = 'linear-gradient(90deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.1))';
          entry.style.borderRadius = '5px';
          entry.style.border = '1px solid rgba(0, 255, 255, 0.3)';
        }
        
        leaderboardContent.appendChild(entry);
      });
    }

    // Main Update Function
    function update() {
      clearCanvas();
      updateCamera();

      drawGrid();
      drawFood();
      drawAIPlayers();
      drawPlayer();
      drawMiniMap();

      // Update game stats
      document.getElementById('scoreDisplay').textContent = player.score;
      document.getElementById('massDisplay').textContent = Math.floor(player.radius);
      document.getElementById('cellsDisplay').textContent = playerPieces.length;

      updateLeaderboard();

      // Check for collision with food (player)
      food.forEach((item, index) => {
        playerPieces.forEach(piece => {
          let dx = piece.x - item.x;
          let dy = piece.y - item.y;
          let distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < piece.radius + item.radius) {
            food.splice(index, 1);
            piece.radius += item.radius / 8;
            player.score += 2;
            
            // Save score to backend
            saveScore(player.score);
          }
        });
      });

      // Move player pieces toward mouse
      playerPieces.forEach(piece => {
        // Convert mouse position to world coordinates
        const worldMouseX = mouseX + camera.x;
        const worldMouseY = mouseY + camera.y;
        
        let dx = worldMouseX - piece.x;
        let dy = worldMouseY - piece.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 5) {
          let speed = Math.max(1, piece.speed - piece.radius / 50);
          let moveX = (dx / distance) * speed;
          let moveY = (dy / distance) * speed;

          piece.x = Math.max(piece.radius, Math.min(piece.x + moveX, gameWidth - piece.radius));
          piece.y = Math.max(piece.radius, Math.min(piece.y + moveY, gameHeight - piece.radius));
        }
      });

      updateAIPlayers();
    }

    // Enhanced Food Generation
    function generateFood() {
      if (food.length < 2000) {
        for (let i = 0; i < 5; i++) {
          let foodX = Math.random() * gameWidth;
          let foodY = Math.random() * gameHeight;
          let foodRadius = Math.random() * 6 + 3;
          let hue = Math.random() * 360;
          let foodColor = `hsl(${hue}, 70%, 60%)`;
          food.push({ x: foodX, y: foodY, radius: foodRadius, color: foodColor });
        }
      }
    }

    // Enhanced Split Function
    function splitPlayer() {
      if (playerPieces.length < 4 && player.radius > 25) {
        playerPieces.forEach((piece, index) => {
          if (piece.radius > 25) {
            const newRadius = piece.radius / 1.4;
            
            const worldMouseX = mouseX + camera.x;
            const worldMouseY = mouseY + camera.y;
            let angle = Math.atan2(worldMouseY - piece.y, worldMouseX - piece.x);
            
            const newPiece = {
              x: piece.x + newRadius * 2 * Math.cos(angle),
              y: piece.y + newRadius * 2 * Math.sin(angle),
              radius: newRadius,
              color: piece.color,
              speed: piece.speed + 1,
              name: piece.name,
              splitTime: Date.now()
            };
            
            piece.radius = newRadius;
            playerPieces.push(newPiece);
          }
        });
      }
    }

    function gameLoop() {
      if (gameRunning) {
        update();
        generateFood();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
    }

    // Save score to backend
    async function saveScore(score) {
      try {
        await fetch('/api/save_score', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ score: score })
        });
      } catch (error) {
        console.error('Failed to save score:', error);
      }
    }

    // Logout function
    function logout() {
      window.location.href = '/logout';
    }

    // Event listeners
    canvas.addEventListener('mousemove', function(event) {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    window.addEventListener('keydown', function(event) {
      if (event.key === ' ') {
        event.preventDefault();
        splitPlayer();
      }
    });

    // Enhanced Start Button
    document.getElementById('startButton').addEventListener('click', function() {
      const nameInput = document.getElementById('nameInput');
      const playerName = nameInput.value.trim();
      
      if (playerName && !gameRunning) {
        player.name = playerName;
        playerPieces[0].name = playerName;
        
        // Clear existing AI players
        allPlayers = [];
        generateAIPlayers();
        
        gameRunning = true;
        gameLoop();
        
        // Hide the name input after starting
        nameInput.style.display = 'none';
        this.textContent = '🎮 PLAYING...';
        this.disabled = true;
      } else if (!playerName) {
        alert('Please enter your name to start!');
        nameInput.focus();
      }
    });

    document.getElementById('stopButton').addEventListener('click', function() {
      if (gameRunning) {
        gameRunning = false;
        cancelAnimationFrame(gameLoopId);
        
        const startBtn = document.getElementById('startButton');
        const nameInput = document.getElementById('nameInput');
        
        startBtn.textContent = '🚀 START GAME';
        startBtn.disabled = false;
        nameInput.style.display = 'block';
      }
    });

    document.getElementById('restartButton').addEventListener('click', function() {
      window.location.reload();
    });

    // Initialize with some food
    for (let i = 0; i < 1000; i++) {
      generateFood();
    }

    // Auto-focus name input
    document.getElementById('nameInput').focus();
  </script> 
</body>
</html>